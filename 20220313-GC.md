# 《垃圾回收的算法与实现》

> 让无法利用的内存实现自动回收再利用（内存资源回收）

## 前置知识

- 随意一门编程语言：C、JAVA、JS、Python 及其他
- 数据结构：堆、栈、链表（建议掌握链表推进）、树（以及树的 DFS & BFS）



## 前置

- What：GC 相当于虚拟内存，一般的虚拟内存技术是在较小物理内存基础上，利用辅助存储创造一片看上去很大的 "虚拟" 地址空间.
  - GC：Grabage Collection, 垃圾回收
    - 垃圾：程序不再使用的内存空间
    - GC要做的事情：找到内存空间的垃圾 &  回收垃圾释放空间
  - 没有 GC 的世界（即手动管理垃圾回收可能出现的问题）
    - 内存泄露：使用后没释放，内存被占满，可能会导致系统崩溃
    - 垂直指针：空间已释放，但指针忘记初始化
    - 错误释放空间：运行错误
  - [ ] TODO: GC 即 "让无法利用的内存实现自动回收再利用（内存资源回收）"，这个定义是否正确
  - [ ] TODO: 下方的论点是描述了什么
    - 即 GC 是扩大内存空间的技术，愿称之为"空间性虚拟存储"
    - 永久提供一次性存储空间的时间轴方向的时间性虚拟存储
    - GC 特征：高负载，需要花费一定时间。即时性程序需要压低 GC 导致的最大暂停时间，其他应用则需要整体处理时间更快
  - [ ] TODO: 学习的意义
    - GC特性：属于高负载处理，需要一定时间花销
    - 意义:
      - 现实场景意义：针对特定场景需要做专项性能指标的优化（例如即时性高的程序需要压低 "最大暂停时间"）
      - 结合算法思考：专项性能的提升需要运用数据结构及算法的结合
      - 学习语言：了解编程语言的 GC 实现，正确评估 GC 性能，方便明确目标场景下的可行性

### 一、名词

- 对象：GC 根据配置将配置好的对象进行移动 or 销毁.  对象是 GC 的基本单位，组成如下：
  - (必备)头 header：包含对象的大小和种类，并包含运行 GC 的信息
  - (必备)域 field：对象中可访问部分，区分指针（根据指针指向查找其他对象）及非指针（基础类型，GC不处理）
  - 其他运行所需信息：例如GC 标记清除中需要 "标志位" 来记录是否已被标记
- Motator：

  - 描述：执行操作行为，行为通常可归类为：生成对象 `new_obj` & 更新指针 `update_ptr`
  - 影响：行为过程中改变"对象引用关系"，产生垃圾，再由 GC 负责回收垃圾
- 堆：```堆末地址 $heap_end = 堆首地址 $heap_start + 堆大小 HEAP_SIZE```
  - 执行 mutator ，GC 负责分配堆空间给 motator，程序将按要求在堆中存放对象。
  - 堆被对象占满后，GC 启动，分配可用空间 or 扩大堆。
- 活动对象/非活动对象
  - 活动对象：分配到内存空间中的对象。反之即为"非活动对象"，无法重新引用，由 GC 销毁
- 分配 allocation：Motator 创建新对象时，向 allocator 申请大小合适的空间
  - 行为区别： 有 GC 则内部分配，无 GC 在则用 malloc() 和 new 手动分配
  - 占满后行为：销毁并报错 or  扩大堆
- 分块 chunk：堆一开始是一个大分块，运行中根据 Mutator 需要分割给活动对象使用，用完作为垃圾被回收，以此往返。
- 根 root：指向内存对象的指针的"起点"
  - 通过 ` for (r : $roots)`  可以枚举所有根引用的对象


### 二、性能评价标准

- 吞吐量：单位时间内的处理能力
  - 计算方式：`吞吐量 = HEAP_SIZE / 时间花销`
  - Tip：对比时不能只看吞吐量，还要将 "检查对象类型"  & "mutator的动作" 考虑在内
  
- 最大暂停时间：GC 执行都会导致 mutator 暂停执行
  - GC 暂停会导致：控制中断、交互界面卡住
  - 限制：大吞吐量 和 短最大暂停时间不可兼得。故面应根据场景指标采用不同算法
- 堆使用效率
  - 影响因子：头大小 & 堆用法
    - 头存储消息越多，GC 效率越高，但头应该尽可能小
    - 堆用法不同，使用率也不同。另外堆使用效率与吞吐量及最大暂停时间不可兼得。
- 访问的局部性
  - PC 四种存储器（小容量高速 -> 大容量低速）： 寄存器、缓存、内存、辅助存储器（硬盘）
  - 具有引用关系的对象安排在堆中较近的位置，就能提高缓存中读取想利用数据的概率，令 mutator 高速运行

## 疑问

- [ ] 没有支持 GC 的硬件是怎么个说法

  ```
  神奇的是，比起称为“垃圾回收”，把GC称为“虚拟内存”令人感觉其重要了许多。当初人们根据计算机体系结构开发了许多关于空间性虚拟存储的支持，所以大部分的计算机都标配了空间性虚拟存储。只要硬件支持，GC性能就能稳步提升，然而现实情况是几乎没有支持GC的硬件，这不能不令人感到遗憾。
  ```

  

## 算法

### 1、标记-清除算法

- 结构：
  - Header：大小、种类、标记位（boolean）

- 实现描述：分"标记"和"清除"阶段。前者标记所有活动对象，后者将没有标记的对象（非活动对象）回收

  - GC 过程：
    - "标记"阶段：递归标记所有活动对象
    - "清除"阶段：从堆头开始遍历，将有标记对象的标志位还原，将无标记对象加入"空闲链表"

  - 使用阶段：
    - 创建对象：遍历"空闲链表"，获取目标大小的块

- 优点：实现简单（组合算法场景也得到简化）、与保守式 GC 算法兼容（保守GC规则为"对象不能被移动"，这里仅做了链接操作）

- 缺点：

  - 碎片化 fragmentation（增加访问时间，可以通过"压缩"及"BiBOP 法"解决）
  - 分配速度慢
    - 标记-清除算法中，每次分配都要遍历"空闲列表"；
    - 而其他算法（复制、标记-压缩）中分块作为"连续的内存空间"存在.
    - 可以通过多个空闲链表 & BiBOP 法加快分配速度

  - 与"写时复制（copy-on-write）"不兼容
    - "写时复制" 的本质：共享内存
    - "写时复制" 的操作要求：不能直接重写共享内存，容易导致数据不一致
    - 与"标记-清除算法"的表现不同，需要使用"位图标记（bitmap marking）"

- 代码实现：

  ```
  mark_sweep() {
  	mark_phase()
  	sweep_phase()
  }
  mark_phase() {
  	for (r: $roots)
  		mark(*r)
  }
  mark(obj) {
  	if (obj.mark == FALSE) {
  		obj.mark = TRUE
  		for (child: children(obj)) {
  			mark(*child) // 递归标记
  		}
  	}
  }
  sweep_phase() {
  	sweeping = $heap_start
  	while (sweeping < $heap_end) {
  		if (sweeping.mark == TRUE) 
  			sweeping.mark = FALSE
  		else
  			sweeping.next = $free_list // 重写 sweeping 的域，因为对象已死所以没有影响
  			$free_list = sweeping // 把垃圾对象连接到空闲链表
      sweeping += sweeping.size
  	}
  }
  ```

- 技术细节

  - 分配过程：mutator 申请分块时，GC 分配回收的垃圾：

    ```
    new_obj (size) {
    	// pickup_chunk 行为（存在多种策略）
    	// 	1、遍历 $free_list 并寻找大于 size 的分块
    	// 	2、如果 size 相同直接返回，size 过大则裁剪后返回
    	chunk = pickup_chunk(size, $free_list)
    	if (chunk != NULL) 
    	 	return chunk
    	else
    		allocation_fail()
    }
    ```

  - 合并 coalescing：合并分配策略产生的小分块

    ```
    sweep_phase() {
    	sweeping = $heap_start
    	while (sweeping < $heap_end) {
    		if (sweeping.mark == TRUE)
    			sweeping.mark = FALSE
    		else
    			// 检查这次的分块和上次的分块是否连续，如果是则合并两个分块
    			if (sweeping == $free_list + $free_list.size) 
    				$free_list.size += sweeping.size
          else
          	sweeping.next = $free_list
          	$free_list = sweeping
    	}
    }
    ```

- [ ] TODO: 「待整理」技术优化：

  - 多个空闲链表：

    - 描述：按照分块大小区分存储（有点桶排序的味道了）

    - 代码实现：修正 new_obj() 及 sweep_heap()

      ```
      new_obj () {
      	index = size / (WORD_LENGTH / BYTE_LENGTH)
      	if (index <= 100) 
      		if ($free_list[index] != NULL) 
      			chunk = $free_list[index] // 获取符合大小的首个块
      			$free_list[index] = $free_list[index].next // 当前链表队首推进为下一个节点
      			return chunk
      	else
      		chunk =  pickup_chunk(size, $free_list[101])
      		if (chunk != NUL) 
          	return chunk
        allocation_fail()
      }
      
      sweep_phase () {
      	for (i: 2..101) 
      		$free_list[i] = NULL
      	sweeping = $heap_start
      	while (sweeping < $heap_end)
        	if (sweeping.mark == TRUE)
        		sweeping.mark = FALSE
          else
              currentIndex = sweeping.size < 101 ? sweeping.size : 101
            	sweeping.next = free_list[index]
      	    	$free_list[sweeping.size] = sweeping
          sweeping += sweeping.size
      }
      ```

  - BiBOP 法（Big Bag Of Pages）：将大小相近的对象整理成固定大小的块进行管理的做法

    - 目标问题：碎片化
    - 解法：堆分割为固定大小的块，让每个块只能配置同样大小的对象
    - 分析：不能完全消除碎片化，可能会降低堆的使用效率

  - 位图标记（bitmap table）

    - 目标问题：标记-清除算法中将标记的位分配到"对象的头"，与"写时复制技术"不兼容

    - 解法：标志位和对象分离，放在表格中管理，可通过数组、散列表、树形结构来实现

      - 重点：标记位和堆中对象应该切实对应

    - 实现：

      ```
      mark(obj) {
      	obj_num = (obj - $heap_start) / WORD_LENGTH
      	index = obj_num / WORD_LENGTH
      	offset = obj_num % WORD_LENGTH
      	
      	if (($bitmap_tbl[index] & (1 << offset)) == 0)
      		$bitmap_tbl[index] |= (1 << offset)
      		for (child : children(obj))
      			mark(*child)
      }
      ```

    - 优点：

      - 兼容写时复制技术

      - 清除更加高效：

        - 之前需要遍历整个堆，将非活动对象连接到空闲链表，并清除活动对象的标志位

        - 现在可以只操作位图标记表格，实现

          ``` 
          sweep_phase () {
          	sweeping = $heap_start
          	index = 0
          	offset = 0
          	
          	while (sweeping < $heap_end)
            	if ($bitmap_tbl[index] & (1 << offset) == 0) // 确定与对象对应的标志位
            		sweeping.next = $free_list
            		$free_list = sweeping
            		index += (offset + sweeping.size) / WORD_LENGTH
            		offset = (offset + sweeping.size) % WORD_LENGTH
            		sweeping += sweeping.size
            for (i : 0..(HEAP_SIZE / WORD_LENGTH - 1))
            	$bitmap_tbl[i] = 0 // 消除标志位
          }
          ```

    - 关注点：重点在于对象地址和位图表格的对应，多个堆时无法通过位运算求取标志位位置，故更优的解法是为每个堆准备一个位图表格互相独立

  - 延迟清除法 Lazy Sweep：

    - 目标问题：花费时间随堆体积增大而延长，影响到 mutator 的处理

    - 处理方法：只在分配时执行必要的遍历，缩减因清除操作导致的 mutator最大暂停时间

    - 实现：

      ```
      new_obj (size) {
      	chunk = lazy_sweep(size) // 尝试清除并分块
      	if (chunk != NULL)
      		return chunk
          
        mark_phase()
        
      	chunk = lazy_sweep(size) // 标记后再次尝试清除并分块
      	if (chunk != NULL)
      		return chunk
        allocation_fail()
      }
      
      lazy_sweep (size) {
        while ($sweeping < $heap_end) 
        	if ($sweeping.mark == TRUE)
        		$sweeping.mark = FALSE
        	else if ($sweeping.size >= size)
        	  chunk = $sweeping
        	  $sweeping += $sweeping.size
        	  return chunk // 一直遍历堆，直到找到大于所申请大小的分块为止
          $sweeping += $sweeping.size
        $sweeping = $heap_start
        return NULL
      }
      ```

    - 分析：

      - 现象：延迟清除使垃圾和活动对象分成两堆
        - 清理垃圾较多部分时可以快速获得分块，减少 mutator 暂停时间
        - 但清理活动对象部分时，无法获得分块，增加了 mutator 暂停时间
      - 结果：清除堆的大小不一定，mutator 的暂停时间难以预测并可能有极端现象发生

### 2、引用计数法 Reference Counting

- 描述：记录"有多少处程序"引用自己的计数器

  - 其他CG算法中，没有分块时 mutator 会调用 GC 函数分配空闲内存空间

  - 但引用计数法中不会，在 mutator 过程中只会通过增减计数器值来进行内存管理，创建和更新两种行为会导致增减的发生

- 特征：将内存管理和 mutator 同时运行，产生垃圾时立即回收

- 优点：

  - 可即刻回收垃圾：内存空间不会被垃圾占据
  - 最大暂停时间短
  - 无需从根开始沿着指针进行查找
    - 基于特性衍生的做法： 在各个计算节点内回收垃圾时使用"GC标记-清除算法"，在考虑节点间引用关系时采用"引用计数法"

- 缺点： 

  - 计数器的增减处理繁重：像其他算法的指针一样频繁更新
  - 计数器占用位数多：计数器最大必须能数完堆中的引用数。（32 位机器需要考虑让 2^32 个对象同时引用一个对象）
  - 实现繁琐易错：更新引用计数需要在 mutator 中调用 update_ptr()，调用的的地方多，如果遗漏就会导致内存管理出 Bug
  - 不能回收 "循环引用"：计数器都是 1，无法回收

- 实现

  - new obj()

    ```
    new_obj (size) {
    	// 引用计数法中，除了连接到空闲链表的对象，其他都是活动对象，当返回 NULL 时，堆中就没有合适大小的分块了
      obj = pickup_chunk(size, $free_list) 
      if (obj == NULL)
      	allocation_fail()
      else
        obj.ref_cnt = 1 // 新生成了对象并被某处引用
        return obj
    }
    ```

  - Update_ptr()：更新指针 ptr 使其指向 obj，同时更新计数器

    ```
    udpate_ptr (ptr, obj) {
    	// 之所以 "先 inc 后 dec"，是为了处理 *ptr & obj 是同一对象的情况 （否则 inc 执行时对象已经被回收了）
      inc_ref_cnt(obj) // 对指针 ptr 新引用的对象 obj 的计数器进行增量操作
      dec_ref_cnt(*ptr) // 对指针 ptr 旧引用的对象 *ptr 的计数器进行减量操作
      *ptr = obj
    }
    inc_ref_cnt (obj) {
      obj.ref_cnt++
    }
    dec_ref_cnt (obj) {
    	obj.ref_cnt--
    	if (obj.ref_cnt === 0)
    		for (child : children(obj))
    			dec_ref_cnt(*child)
    		reclaim(obj) // 将 obj 连接到空闲链表
    }
    ```

- 改良方案：稍加改良就非常具备实用性

  - 延迟引用计数法：

    - 缺陷分析：计数器增删处理繁重 => 本质问题是：根的引用变化繁重

    - 应对方案：让根引用指针的变化不反映在计数器上
      - Step1：`update_ptr($ptr, obj)`  改为 `*$ptr=obj`
      - Step2：使用 `ZCT（Zero Count Table）` 记录下计数器值在 `dec_ref_count` 作用下变为 0 的对象

    - 实现：

        - 修改 def_ref_count 实现

          ```
          dec_ref_count (obj) {
            obj.ref_count--
            if (obj.ref_count == 0) 
              if (is_full($zct) == TRUE)
                scan_zct() // $zct 如果爆满则通过 scan_zct() 函数来减少 $zct 中的对象
              push($zct, obj) // 把 obj 添加到 $zct
          }
          ```

        - 修改 new_obj 实现

           ```
           new obj () {
           	obj = pickup_chunk(size, $free_list)
           	if (obj == NULL) 
           		scan_zct()
           		obj = pickup_chunk(size, $free_list)
           		if (ob == NULL)
           			allocation_fail()
               obj.ref_cnt = 1
               return obj
           }
           ```

        - 实现 scan_zct

          ```
          scan_zct () {
            for (r: $roots)
            	(*r).ref_cnt++ // 将所有通过根引用的对象进行增量
            for (obj : $zct)
            	if (obj.ref_cnt == 0)
            		remove($zct, obj) // 调查所有与 $zct 相连的对象，如果计数器为 0，则减量并回收
            		delete(obj)
            for (r: $roots)
            	(*r).ref_cnt--
          }
          delete (obj) {
            for (child : children(obj))
            	(*child).ref_cnt--
            	if ((*child).ref_cnt == 0)
            		delete(*child)
            reclaim(obj)
          }
          ```
        
    - 延迟引用计数法优点：由此减轻了计数器增减负担
    
    - 延迟引用计数法缺点：
    
        - 失去引用计数法一大优点 -- 可即刻回收垃圾
        - 导致最大暂停时间延长，执行 scan_zcf() 的时间花销和 $zct 的大小成正比
    
  - Sticky 引用计数法

    - 目标：减少计数器位宽

    - 处理"超出计数器位宽情况"的方法：

      - 什么都不做：计数器值大到溢出说明该对象及其重要，故无需考虑其销毁回收

      - 使用 GC标记-清除算法处理（和之前的有所不同）

        ```
        mark_sweep_for_counter_overflow () {
          reset_all_ref_cnt()
          mark_phase()
          sweep_phase()
        }
        reset_all_ref_cnt () {
          // 清零所有计数器
        }
        mark_phase () {
        	for (r : $roots)
          	push(*r, $mark_stack) // 将根直接引用的对象堆到标记堆里
          while (is_empty($mark_stack) == FALSE)
            obj = pop($mark_stack)
            obj.ref_cnt++ // 按序取出对象并增量
            if (obj.ref_cnt == 1) // 检查是否只进堆一次
              for (child : children(obj))
              	push(*child, $mark_stack)
        }
        sweep_phase () {
        	sweeping = $heap_top
        	while (sweeping < $head_end)
        		if (sweeping.ref_cnt == 0)
        			reclaim(sweeping) // 搜索整个堆，回收计数器仍为 0 的对象
            sweeping += sweeping.size
        }
        ```

    - 区别：

      - 一开始将所有对象计数器为 0
      - 不标记对象，而是对计数器做增量
      - 搜索不止一次

    - 优点：能循环回收垃圾

    - 缺点：时间花销更大，吞吐量减小

  - 1位引用计数法

    - What：Stricky 引用计数法的极端例子，计数器只有 1 位，瞬间溢出.

    - 用法：通常 0 表示被引用数为 1，1 表示被引用数大于等于 2

    - 实现：利用 "指针通常默认 4 字节对齐，无法利用低 2 位"的性质

      ```
      // 通过复制指针实现更新
      copy_ptr (dest_ptr, src_ptr) {
      	delete_ptr(dest_str)
      	*dest_ptr = *src_ptr
      	set_multiple_tag(dest_ptr)
      	if (tag(src_ptr) == UNIQUE)
        	set_multiple_tag(src_ptr) // 如果是 UNIQUE 则转为 MULTIPLE 指针
      }
      delete_ptr (ptr) {
      	if (tag(ptr) == UNIQUE)
        	reclaim(*ptr)
      }
      ```

    - 优点：不易出现高速缓存缺失

      - 无需再更新计数器是读取引用对象，仅复制指针 & 计时器空间减少，节省了内存消耗量

    - 缺点：需要处理计数器溢出的对象，但mutator的错误运行可能会导致许多对象计数器溢出，导致分块难以保证

  - 部分标记-清除算法（Partical Mark & Sweep）

    - 背景：引用计数法无法处理循环垃圾，标记-清除算法可以。那么就只在"可能有循环引用的对象群"使用标记-清除算法.

    - 与"标记-清除算法"的区别："标-清"查找活动对象，"部分标-清"查找非活动对象

    - 循环垃圾的产生过程：产生循环引用，然后删除外部到循环引用的引用

    - 局限性：从队列搜索对象的成本高，增加时间花销；引用计数法失去"最大暂停时间"的优势

    - 算法：

      - 区分颜色管理：

        - 黑：绝对非垃圾，初始颜色
        - 白：绝对垃圾
        - 灰：搜索完毕
        - 阴影：循环垃圾

      - 处理位置：

        - 通过 mutator 删除由根到对象 A 的引用

          ```
          dec_ref_cnt (obj) {
            obj.ref_cnt--
            if (obj.ref_cnt == 0)
            	delete(obj)
            else if (obj.color != HATCH)
            	obj.color = HATCH
            	enqueue(obj, $hatch_queue) // 非空即循环引用，涂上阴影并加入队列
          }
          ```

        - new Obj

          ```
          new_obj (size) {
          	obj = pickup_chunk(size)
          	if (obj != NULL)
          		obj.color = BLACK
          		obj.ref_cnt = 1
          		return obj // 分配后初始化为黑色
            else if (is_empty($hatch_queue) == FALSE)
            	scan_hatch_queue() // 搜索"部分标记-清除算法"的队列，并分块
            	return new_obj(size)
            else
              allocation_fail()
          } 
          scan_hatch_queue () {
            obj = dequeuue($hatch_queue)
            if (obj.color == HATCH)
            	// 以下三步的目标是找到循环引用的垃圾并回收
              paint_gray(obj) // 查找对象进行计数器减量操作（标记、递归）
              scan_gray(obj) // 搜索灰色，把 计数器=0 的对象涂白
              collect_white(obj)
            else if (is_empty($hatch_queue) == FALSE)
            	scan_hatch_queue()
          }
          paint_gray (obj) {
            if (obj.color == (BLACK | HATCH))
            	obj.color = GRAY
            	for (child: children(obj))
            		(*child).ref_cnt--
            		paint_gray(*child)
          }
          scan_gray (obj) {
          	if (obj.color == GRAY)
            	if (obj.ref_cnt > 0)
            		paint_black(obj) // 从标记的对象群中找到不是垃圾的对象，还原为黑色
            	else
            		obj.color = WHITE
            		for (child: children(obj))
            			scan_gray(*child)
          }
          paint_black (obj) {
            obj.color = BLACK
            for (child: children(obj))
            	(*child).ref_cnt++
            	if ((*child).color != BLACK)
            		paint_black(*child)
          }
          collect_white (obj) {
          	if (obj.color == WHITE)
            	obj.color = BLACK
            	for (child: children(obj))
            		collect_white (*child)
              reclaim(obj)
          }
          ```


### 3、复制算法

- 描述：把内存分为两个大小一的空间，把 A 空间的活动对象复制到 B 空间，然后倾倒 A 空间

- 实现：

  - 复制算法

    ```
    copying () {
      $free = $to_start // 分块开头
      for (r : $roots)
        *r = copy(*r) // 复制后返回指针，指向 *r 所在的新空间的对象
      swap($from_start, $to_start) // 交换空间
    }
    copy (obj) {
      if (obj.tag != COPIED)
        copy_data($free, obj, obj.size)
        obj.tag = COPIED // 标记已复制
        obj.forwarding = $free // 记录新空间指针
        $free += obj.size
        for (child : children(obj.forwarding))
          *child = copy(*child)
      return obj.forwarding // 复制完成后返回新空间对象地址
    }
    ```

  - GC 复制算法的分配过程实现

    ```
    new obj (size) {
    	if ($free + size > $from_start + HEAP_SIZE/2) // HEAP_SIZE 表示是把 From 空间和 To 空间加起来的大小
      	copying()
      	if ($free + size > $from_start + HEAP_SIZE/2)
      		allocation_fail()
      	// 记录位置及大小，更新指针地址
        obj = $free
        obj.size = size
        $free += size
        return obj
    }
    ```

- 优点：

  - 优秀的吞吐量：
    - GC 标记-清除吞吐量 = 标记（搜索活动对象） + 清除（搜索整体堆）
    - GC 复制算法吞吐量  = 只搜索并复制活动对象，能短时间内完成 GC
    - 堆越大，差距越明显

  - 高速分配：
    - GC 复制算法：其分块是连续内存空间，无需空间链表，分配只需移动 $free 指针
    - GC 标记清除算法：最坏情况要遍历整个空闲链表

  - 不会碎片化：基于算法性质，活动对象被集中安排，无意中执行了"压缩"过程（去碎片，有引用关系放相近位置）
  - 兼容缓存：基于算法性质，有引用关系的对象会被安排在堆中里彼此比较近的位置，这样 mutator 执行极快.

- 缺点：

  - 堆使用效率低：只能使用一半，可组合使用解决
  - 不兼容保守式 GC 算法：基于算法性质必须移动对象 & 重写指针，但可以组合
  - 递归调用函数：递归可能导致栈溢出

- 优化方案：

  - Cheney：

    - 目标：不递归，而是迭代复制

    - 算法性质：BFS

    - 实现：

      ```
      copying () {
      	scan = $free = $to_start // scan 用于搜索复制完成的对象的指针，$free 指向分块开头
      	for (r : $roots)
      		*r = copy(*r)
        while (scan != $free)
        	for (child: children(scan))
        		*child = copy(*child)
        	scan += scan.size
        swap($from_start, $to_start)
      }
      copy (obj) {
        if (is_pointer_to_heap(obj.forwarding, $to_start) == FALSE)
        	copy_data($free, obj, obj.size)
        	obj.forwarding = $free
        	$free += obj.size
        return obj.forwarding
      }
      ```

    - [ ] 近似深度优先搜索

    - [ ] 多空间复制算法：提高利用率，N 等分堆，其中两块空间执行 GC 复制算法，其他（N-2）块空间执行 GC 标记-清除算法

- [ ] 复习

  - 原因：三种基础 GC 算法的组合使用，衍生出了后续的算法，在这里明确算法特点及对比算法差异，有助于加速后续学习

### 4、标记-压缩算法

- 标记过程和标记-清理算法一致
- 搜索数次堆实现压缩，不同于 GC复制，该算法无需牺牲半个堆
- 压缩实现
  - 遍历堆，为有标记的对象设置 forwarding 指针
  - 更新所有根引用对象的指针，再次遍历堆，重写所有活动对象的指针
  - 执行移动
- 优点：堆利用效率高，有压缩过程，不会尝试碎片化
- 缺点：时间花销高

### 5、保守式 GC

- [ ] 官方提问：判定"指针及非指针"需要一定花销，需要注意程序是否支持

- 保守式 GC：不能识别指针和非指针的 GC. 对于无法识别的对象，保存即可。
- 明确式 GC：增加语言实现成本，类型明确
- 保守式 GC 无法复制:
  - 原因：无法识别是否指针，重写的对象可能是非指针
  - 解决方法：
- 黑名单缓解了保守式 GC 的"错误识别指针导致压迫堆"的问题，但是需要在分配对象时增加检查黑名单的花销

### 6、分代垃圾回收

### 7、增量式垃圾回收

### 8、RC Immix 算法

- [x] 回顾 -> 记录在 Note 了
- [ ] 尝试看完再开始记笔记
- [ ] 整理脑图

## 实现

Tip：着重关注 V8 实现

